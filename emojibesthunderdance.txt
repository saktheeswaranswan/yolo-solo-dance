let posePlayer;
const fps = 30;
const poseWidth = 640;
const poseHeight = 480;

// Skeleton edges
const skeletonEdges = [
  [5, 7], [7, 9], [6, 8], [8, 10],
  [11, 13], [13, 15], [12, 14], [14, 16],
  [5, 6], [11, 12], [5, 11], [6, 12]
];

function preload() {
  posePlayer = new PosePlayer('Hghdugfy.mp4', 'salambalasalambala.json');
}

function setup() {
  createCanvas(1280, 720);
  frameRate(fps);
  posePlayer.setup();
}

function draw() {
  background(0);
  ThunderEffect.show(); // Thunder effect layer
  posePlayer.update();
  posePlayer.display();
}

function keyPressed() {
  posePlayer.handleKey(key.toUpperCase());
}

// ---------------- Thunder Effect ----------------
class ThunderEffectClass {
  static lastStrike = 0;
  static nextInterval = 0;

  static show() {
    if (millis() - this.lastStrike > this.nextInterval) {
      this.strike();
      this.lastStrike = millis();
      this.nextInterval = random(1000, 5000); // random interval between strikes
    }
  }

  static strike() {
    push();
    fill(255, random(100, 200));
    rect(0, 0, width, height);
    pop();
  }
}
const ThunderEffect = ThunderEffectClass;

// ---------------- PosePlayer Class ----------------
class PosePlayer {
  constructor(videoFile, poseJSONFile) {
    this.videoFile = videoFile;
    this.poseJSONFile = poseJSONFile;

    this.poseMap = {};
    this.video = null;
    this.poseTime = 0;
    this.playing = false;
    this.showPose = true;
    this.playbackRate = 1;

    // Skeleton & keypoint scale
    this.scaleCycle = [1, 0.75, 0.5, 0.25];
    this.scaleIndex = 0;
    this.scaleFactor = 1;

    // Emoji / keypoint size
    this.pointSizeCycle = [6, 12, 18, 24, 36];
    this.pointSizeIndex = 1;
    this.pointSize = this.pointSizeCycle[this.pointSizeIndex];
    this.headEmojiSize = 72; // Big emoji

    // Drag control
    this.offsetX = 0;
    this.offsetY = 0;
    this.isDragging = false;
    this.dragStartX = 0;
    this.dragStartY = 0;

    this.speedInput = null;
    this.isLoaded = false;
  }

  setup() {
    this.loadJSONData();
    this.loadVideo();
    this.setupControls();
  }

  loadJSONData() {
    loadJSON(this.poseJSONFile, data => {
      this.preparePoseMap(data);
      this.checkIfLoaded();
    });
  }

  loadVideo() {
    this.video = createVideo([this.videoFile], () => {
      this.video.hide();
      this.video.volume(0);
      this.video.elt.muted = true;
      this.checkIfLoaded();
    });
  }

  checkIfLoaded() {
    if (this.video && Object.keys(this.poseMap).length > 0) {
      this.isLoaded = true;
      this.play();
    }
  }

  preparePoseMap(data) {
    (Array.isArray(data) ? data : Object.values(data)).forEach(entry => {
      if (!this.poseMap[entry.frame_id]) this.poseMap[entry.frame_id] = [];
      this.poseMap[entry.frame_id].push(entry.keypoints);
    });
  }

  update() {
    if (!this.isLoaded || !this.playing) return;

    this.poseTime += (deltaTime / 1000) * this.playbackRate;
    if (this.video.time() !== this.poseTime) this.video.time(this.poseTime);

    const lastFrame = Math.max(...Object.keys(this.poseMap).map(Number)) / fps;
    if (this.poseTime >= lastFrame) this.stop();
  }

  display() {
    if (!this.isLoaded) {
      this.showLoading();
      return;
    }
    if (this.video.elt.readyState >= 2) image(this.video, 0, 0, width, height);
    if (this.showPose) this.drawPoseOverlay();
  }

  showLoading() {
    push();
    textSize(36);
    fill(255);
    textAlign(CENTER, CENTER);
    text('Loading...', width / 2, height / 2);
    pop();
  }

  drawPoseOverlay() {
    const frameIndex = floor(this.poseTime * fps);
    const persons = this.poseMap[frameIndex] || [];

    push();
    translate(this.offsetX, this.offsetY);
    scale(this.scaleFactor);

    const scaleX = width / poseWidth;
    const scaleY = height / poseHeight;

    stroke(255, 255, 0);
    strokeWeight(4 / this.scaleFactor);
    persons.forEach(kpts => {
      skeletonEdges.forEach(([i, j]) => {
        const a = kpts[i], b = kpts[j];
        if (a && b) line(a[0]*scaleX, a[1]*scaleY, b[0]*scaleX, b[1]*scaleY);
      });
    });

    noStroke();
    fill(255, 0, 0);
    textAlign(CENTER, CENTER);
    textSize(this.pointSize);
    persons.forEach(kpts => {
      kpts.forEach((p, idx) => {
        if (p) ellipse(p[0]*scaleX, p[1]*scaleY, this.pointSize);
        if (idx === 0 && p) {
          textSize(this.headEmojiSize);
          text('ðŸ˜‚', p[0]*scaleX, p[1]*scaleY - this.headEmojiSize / 1.5);
        }
      });
    });

    pop();
  }

  setupControls() {
    const yBase = height - 60;

    createButton('Play').position(20, yBase).mousePressed(() => this.play());
    createButton('Pause').position(100, yBase).mousePressed(() => this.pause());
    createButton('Stop').position(180, yBase).mousePressed(() => this.stop());
    createButton('Scale').position(260, yBase).mousePressed(() => this.cycleScale());
    createSpan('Speed:').position(340, yBase + 5);
    this.speedInput = createInput('1.0').position(400, yBase).size(50);
    this.speedInput.input(() => this.setSpeed());
  }

  cycleScale() {
    this.scaleIndex = (this.scaleIndex + 1) % this.scaleCycle.length;
    this.scaleFactor = this.scaleCycle[this.scaleIndex];
    this.pointSizeIndex = (this.pointSizeIndex + 1) % this.pointSizeCycle.length;
    this.pointSize = this.pointSizeCycle[this.pointSizeIndex];
  }

  setSpeed() {
    const val = parseFloat(this.speedInput.value());
    this.playbackRate = isNaN(val) ? 1 : val;
    if (this.video) this.video.speed(this.playbackRate);
  }

  play() { this.playing = true; this.video.play(); this.video.speed(this.playbackRate); }
  pause() { this.playing = false; this.video.pause(); }
  stop() { this.playing = false; this.poseTime = 0; this.video.pause(); this.video.time(0); }

  handleKey(k) {
    if (k === 'T') this.showPose = !this.showPose;
    if (k === 'P') this.playing ? this.pause() : this.play();
  }

  mousePressed() {
    if (this.showPose) {
      this.isDragging = true;
      this.dragStartX = mouseX - this.offsetX;
      this.dragStartY = mouseY - this.offsetY;
    }
  }

  mouseDragged() {
    if (this.isDragging) {
      this.offsetX = mouseX - this.dragStartX;
      this.offsetY = mouseY - this.dragStartY;
    }
  }

  mouseReleased() { this.isDragging = false; }
}

// Global mouse events
function mousePressed() { posePlayer.mousePressed(); }
function mouseDragged() { posePlayer.mouseDragged(); }
function mouseReleased() { posePlayer.mouseReleased(); }
